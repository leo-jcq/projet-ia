var I=Object.defineProperty;var D=(a,t,e)=>t in a?I(a,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):a[t]=e;var h=(a,t,e)=>D(a,typeof t!="symbol"?t+"":t,e);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))i(s);new MutationObserver(s=>{for(const o of s)if(o.type==="childList")for(const n of o.addedNodes)n.tagName==="LINK"&&n.rel==="modulepreload"&&i(n)}).observe(document,{childList:!0,subtree:!0});function e(s){const o={};return s.integrity&&(o.integrity=s.integrity),s.referrerPolicy&&(o.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?o.credentials="include":s.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function i(s){if(s.ep)return;s.ep=!0;const o=e(s);fetch(s.href,o)}})();var w=(a=>(a.Easy="easy",a.Medium="medium",a.Hard="hard",a))(w||{});const E={easy:{size:10,nbMines:10},medium:{size:18,nbMines:40},hard:{size:24,nbMines:99}};var _=(a=>(a.Visual="visual",a.Performance="perf",a))(_||{});const S=w.Easy,C=100,v=0,M=500,p=1,G=1,k=_.Visual,N="RÃ©initialiser",L="Commencer";var f=(a=>(a[a.Start=0]="Start",a[a.Solving=1]="Solving",a[a.Solved=2]="Solved",a))(f||{}),u=(a=>(a.Discover="d",a.Mark="m",a))(u||{});const $={d:"DÃ©couverte",m:"Marquage"};var l=(a=>(a.Covered="covered",a.Marked="marked",a.Discovered="discovered",a))(l||{});class F{constructor(t){h(this,"_hasMine");h(this,"_state");h(this,"nbMinesAround");this._hasMine=t,this._state=l.Covered,this.nbMinesAround=0}get hasMine(){return this._hasMine}get state(){return this._state}discover(){this._state===l.Covered&&(this._state=l.Discovered)}toggleMarked(){this._state!==l.Discovered&&(this._state=this._state===l.Marked?l.Covered:l.Marked)}toString(){switch(this._state){case l.Covered:return"  ";case l.Marked:return"ðŸš©";case l.Discovered:return this._hasMine?"ðŸ’£":`${this.nbMinesAround} `}}toHtml(t,e){const i="game-cell";let s=`${i} ${i}--${this._state}`;return this._state===l.Discovered&&(s+=` ${i}--${this._hasMine?"mine":this.nbMinesAround}`),`
        <button class="${s}" data-row="${t}" data-column="${e}">
            ${this.toString().trim().replace("0","")}
        </button>
        `}}class z{constructor(t){h(this,"_size");h(this,"_nbMines");h(this,"_cells");const{size:e,nbMines:i}=E[t];this._size=e,this._nbMines=i,this._cells=[],this.initCells(),this.calculateNbMinesAround()}initCells(){let t=this._nbMines,e=this.nbCells;for(let i=0;i<this._size;i++){const s=[];for(let o=0;o<this._size;o++){let n=!1;const r=t/e;Math.random()<r&&(n=!0,t--),s.push(new F(n)),e--}this._cells.push(s)}}calculateNbMinesAround(){for(let t=0;t<this._size;t++)for(let e=0;e<this._size;e++){const i=this._cells[t][e];this.forEachNeighbors({row:t,column:e},(s,o)=>{o.hasMine&&i.nbMinesAround++})}}getCell(t){var e;return(e=this._cells[t.row])==null?void 0:e[t.column]}forEachNeighbors(t,e){const{row:i,column:s}=t;for(let o=i-1;o<=i+1;o++)for(let n=s-1;n<=s+1;n++){const r={row:o,column:n},d=this.getCell(r);d&&e(r,d)}}discoverNeighbors(t){this._cells[t.row][t.column].nbMinesAround===0&&this.forEachNeighbors(t,(i,s)=>{s.state!==l.Discovered&&(s.discover(),this.discoverNeighbors(i))})}get size(){return this._size}get nbCells(){return this._size*this._size}get nbMines(){return this._nbMines}get cells(){return this._cells}get nbMinesLeft(){const t=this._cells.flat().filter(e=>e.state===l.Marked);return this.nbMines-t.length}get isWin(){return this._cells.flat().every(t=>t.hasMine&&t.state!==l.Discovered||!t.hasMine&&t.state===l.Discovered)}get isLoose(){return this._cells.flat().some(t=>t.state===l.Discovered&&t.hasMine)}get isEnd(){return this.isWin||this.isLoose}performAction(t){const{coordinates:e,type:i}=t,s=this.getCell(e);if(!s)throw new Error(`Aucune cellule aux coordonnÃ©es (${e.row}, ${e.column}).`);switch(i){case u.Discover:s.discover(),!s.hasMine&&s.state===l.Discovered&&this.discoverNeighbors(e);break;case u.Mark:s.toggleMarked();break}}toString(){let t="";t+=this.printColNumbers();for(let e=0;e<this._size;e++)t+=this.lineHeaderToString()+this.printRowNumber(e)+this.printCells(e);return t+=this.lineHeaderToString(),t}lineHeaderToString(){let t="   -";for(let e=0;e<this._size;e++)t+="---";return t+=`
`,t}printColNumbers(){let t="  ";for(let e=0;e<this._size;e++){const i=e+1;i<10?t+=`  ${i}`:t+=`  ${i}`}return t+=`
`,t}printRowNumber(t){let e="";const i=t+1;return i<10?e+=` ${i}`:e+=i,e+=" ",e}printCells(t){let e="|";for(let i=0;i<this._size;i++)e+=`${this._cells[t][i].toString()}|`;return e+=`
`,e}toHtml(){let t="";t+='<span class="grid-number"></span>';for(let e=0;e<this._size;e++)t+=`<span class="grid-number">${e+1}</span>`;for(let e=0;e<this._size;e++){t+=`<span class="grid-number">${e+1}</span>`;for(let i=0;i<this._size;i++)t+=this.cells[e][i].toHtml(e,i)}return t}}class A{constructor(t){h(this,"grid");h(this,"_knownGrid");h(this,"_continueSolve");this.grid=new z(t),this._knownGrid=[],this._continueSolve=!0,this.initializeKnownGrid()}initializeKnownGrid(){for(let t=0;t<this.grid.size;t++){this._knownGrid[t]=[];for(let e=0;e<this.grid.size;e++)this._knownGrid[t][e]={state:l.Covered}}}updateKnownGrid(){for(let t=0;t<this.grid.size;t++)for(let e=0;e<this.grid.size;e++){const i=this.grid.cells[t][e],s=this._knownGrid[t][e];s.state=i.state,i.state===l.Discovered&&(s.nbMinesAround=i.nbMinesAround)}}getNeighbors(t){const{row:e,column:i}=t,s=[];for(let o=e-1;o<=e+1;o++)for(let n=i-1;n<=i+1;n++)o>=0&&o<this.grid.size&&n>=0&&n<this.grid.size&&s.push({row:o,column:n});return s}async findSafeAction(){for(let t=0;t<this.grid.size;t++)for(let e=0;e<this.grid.size;e++){const i=this._knownGrid[t][e];if(i.state===l.Discovered&&i.nbMinesAround!==void 0){const s=this.getNeighbors({row:t,column:e}),o=s.filter(r=>this._knownGrid[r.row][r.column].state===l.Covered);if(o.length===0)continue;const n=s.filter(r=>this._knownGrid[r.row][r.column].state===l.Marked);if(n.length===i.nbMinesAround)return{type:u.Discover,coordinates:o[0]};if(o.length===i.nbMinesAround-n.length)return{type:u.Mark,coordinates:o[0]}}}return null}async findLeastRiskyMove(){const t=[],e=this._knownGrid.flat(),i=e.filter(n=>n.state===l.Covered),s=e.filter(n=>n.state===l.Marked),o=i.length===0?0:(this.grid.nbMinesLeft-s.length)/i.length;for(let n=0;n<this.grid.size;n++)for(let r=0;r<this.grid.size;r++)if(this._knownGrid[n][r].state===l.Covered){const d={row:n,column:r},c=await this.calculateMineProbability(d,o);t.push({coordinates:d,probability:c})}return t.length===0?null:(t.sort((n,r)=>n.probability-r.probability),{type:u.Discover,coordinates:t[0].coordinates})}async calculateMineProbability(t,e){const i=this.getNeighbors(t).filter(n=>this._knownGrid[n.row][n.column].state===l.Discovered);let s=0,o=0;for(const n of i){const r=this._knownGrid[n.row][n.column];if(r.nbMinesAround!==void 0){const d=this.getNeighbors(n),c=d.filter(g=>this._knownGrid[g.row][g.column].state===l.Covered),m=d.filter(g=>this._knownGrid[g.row][g.column].state===l.Marked);s+=Math.max(0,r.nbMinesAround-m.length),o+=c.length}}return o>0?s/o:e}stopSolving(){this._continueSolve=!1}async solve(){const t=Date.now(),e={coordinates:{row:0,column:0},type:u.Discover};for(this.grid.performAction(e);!this.grid.isEnd&&this._continueSolve;){this.updateKnownGrid();let i=await this.findSafeAction();if(!i&&(i=await this.findLeastRiskyMove(),!i))break;this.grid.performAction(i)}return Date.now()-t}}function b(a){return new Promise(t=>setTimeout(t,a))}class y{constructor(t,e,i,s,o){h(this,"grid");h(this,"_knownGrid");h(this,"_delay");h(this,"showFullSolving");h(this,"printConsole");h(this,"_continueSolve");h(this,"_gameGrid");h(this,"_history");this.grid=new z(t),this._knownGrid=[],this._delay=e,this.showFullSolving=i,this._continueSolve=!0,this._gameGrid=s,this._history=o,this.printConsole=!1,this.initializeKnownGrid()}initializeKnownGrid(){for(let t=0;t<this.grid.size;t++){this._knownGrid[t]=[];for(let e=0;e<this.grid.size;e++)this._knownGrid[t][e]={state:l.Covered}}}updateKnownGrid(){for(let t=0;t<this.grid.size;t++)for(let e=0;e<this.grid.size;e++){const i=this.grid.cells[t][e],s=this._knownGrid[t][e];s.state=i.state,i.state===l.Discovered&&(s.nbMinesAround=i.nbMinesAround)}}getNeighbors(t){const{row:e,column:i}=t,s=[];for(let o=e-1;o<=e+1;o++)for(let n=i-1;n<=i+1;n++)o>=0&&o<this.grid.size&&n>=0&&n<this.grid.size&&s.push({row:o,column:n});return s}async findSafeAction(){for(let t=0;t<this.grid.size;t++)for(let e=0;e<this.grid.size;e++){this.showFullSolving&&this.display({row:t,column:e});const i=this._knownGrid[t][e];if(i.state===l.Discovered&&i.nbMinesAround!==void 0){const s=this.getNeighbors({row:t,column:e}),o=s.filter(r=>this._knownGrid[r.row][r.column].state===l.Covered);if(o.length===0)continue;const n=s.filter(r=>this._knownGrid[r.row][r.column].state===l.Marked);if(n.length===i.nbMinesAround)return{type:u.Discover,coordinates:o[0]};if(o.length===i.nbMinesAround-n.length)return{type:u.Mark,coordinates:o[0]};this.showFullSolving&&await b(this._delay)}}return null}async findLeastRiskyMove(){const t=[],e=this._knownGrid.flat(),i=e.filter(n=>n.state===l.Covered),s=e.filter(n=>n.state===l.Marked),o=i.length===0?0:(this.grid.nbMinesLeft-s.length)/i.length;for(let n=0;n<this.grid.size;n++)for(let r=0;r<this.grid.size;r++){const d={row:n,column:r};if(this.showFullSolving&&this.display(d),this._knownGrid[n][r].state===l.Covered){const c=await this.calculateMineProbability(d,o);t.push({coordinates:d,probability:c})}this.showFullSolving&&await b(this._delay)}return t.length===0?null:(t.sort((n,r)=>n.probability-r.probability),{type:u.Discover,coordinates:t[0].coordinates})}async calculateMineProbability(t,e){this.showFullSolving&&(await b(this.delay),this.display(t));const i=this.getNeighbors(t).filter(n=>this._knownGrid[n.row][n.column].state===l.Discovered);let s=0,o=0;for(const n of i){this.showFullSolving&&(await b(this.delay),this.display(t));const r=this._knownGrid[n.row][n.column];if(r.nbMinesAround!==void 0){const d=this.getNeighbors(n),c=d.filter(g=>this._knownGrid[g.row][g.column].state===l.Covered),m=d.filter(g=>this._knownGrid[g.row][g.column].state===l.Marked);s+=Math.max(0,r.nbMinesAround-m.length),o+=c.length}}return o>0?s/o:e}displayAction(t){if(!this._history)return;const{coordinates:e,type:i}=t,s=$[i],o=`(${e.row+1}, ${e.column+1})`;this._history.textContent+=`${s} de la case ${o}
`}get delay(){return this._delay}set delay(t){t>=v&&t<M&&(this._delay=t)}display(t){if(this._gameGrid){if(this._gameGrid.innerHTML=this.grid.toHtml(),t){const e=document.querySelector(`.game-cell[data-row="${t.row}"][data-column="${t.column}"]`);e&&e.classList.add("game-cell--current")}}else this.printConsole&&(console.clear(),console.log(this.grid.toString()))}stopSolving(){this._continueSolve=!1}async solve(){const t=Date.now(),e={coordinates:{row:0,column:0},type:u.Discover};for(this.display(this.showFullSolving?e.coordinates:void 0),this.grid.performAction(e),this.display(this.showFullSolving?e.coordinates:void 0);!this.grid.isEnd&&this._continueSolve;){this.updateKnownGrid();let i=await this.findSafeAction();if(!i&&(i=await this.findLeastRiskyMove(),!i))break;this.showFullSolving&&this.display(i.coordinates),this.grid.performAction(i),this.displayAction(i),this.display(this.showFullSolving?i.coordinates:void 0),await b(this._delay)}if(this.grid.isWin){for(let i=0;i<this.grid.size;i++)for(let s=0;s<this.grid.size;s++)if(this._knownGrid[i][s].state===l.Covered){const n={coordinates:{row:i,column:s},type:u.Mark};this.grid.performAction(n),this.display(),this.displayAction(n),await b(this._delay)}}return Date.now()-t}}class B{constructor(){h(this,"_bot");h(this,"_gameGrid");h(this,"_history");h(this,"_difficultySelect");h(this,"_delayInput");h(this,"_delayLabel");h(this,"_showFullInput");h(this,"_nbGamesInput");h(this,"_showAllGames");h(this,"_modeSelect");h(this,"_mainBtn");h(this,"_statusMessage");h(this,"_step");this._gameGrid=document.getElementById("game-grid"),this._history=document.getElementById("history"),this._mainBtn=document.getElementById("main-btn"),this._statusMessage=document.getElementById("status-message"),this._difficultySelect=document.getElementById("difficulty-select"),this._difficultySelect.value=S,this._delayInput=document.getElementById("delay-input"),this._delayInput.value=C.toString(),this._delayInput.min=v.toString(),this._delayInput.max=M.toString(),this._delayLabel=document.getElementById("delay-input-label"),this.displayDelay(),this._showFullInput=document.getElementById("show-full-input"),this._nbGamesInput=document.getElementById("nb-games-input"),this._nbGamesInput.value=p.toString(),this._nbGamesInput.min=G.toString(),this._showAllGames=document.getElementById("show-all-games-input"),this._modeSelect=document.getElementById("mode-select"),this._modeSelect.value=k,this._bot=new y(this.getCurrentDifficulty(),parseInt(this._delayInput.value),this._showFullInput.checked,this._gameGrid,this._history),this._step=f.Start,this.initEventListeners(),this._gameGrid.style.setProperty("--grid-size",this._bot.grid.size.toString()),this._bot.display()}getCurrentDifficulty(){switch(this._difficultySelect.value){case w.Easy:case w.Medium:case w.Hard:break;default:this._difficultySelect.value=S;break}return this._difficultySelect.value}getCurrentNbGames(){let t=parseInt(this._nbGamesInput.value);return(isNaN(t)||t<G)&&(t=p,this._nbGamesInput.value=p.toString()),t}initEventListeners(){this._difficultySelect.addEventListener("input",this.newGame.bind(this)),this._delayInput.addEventListener("input",this.handleDelayChange.bind(this)),this._showFullInput.addEventListener("change",this.handleShowFullChange.bind(this)),this._modeSelect.addEventListener("change",this.handleModeChange.bind(this)),this._mainBtn.addEventListener("click",this.handleMainBtnClick.bind(this))}handleMainBtnClick(){switch(this._step){case f.Start:this._mainBtn.textContent=N,this.startGame();break;case f.Solved:this._mainBtn.textContent=L,this.newGame();break}}initNewBot(t){this._modeSelect.value===_.Visual?(this._bot=new y(t,parseInt(this._delayInput.value),this._showFullInput.checked,this._gameGrid,this._history),this._bot.display()):(this._bot=new A(t),this._gameGrid.innerHTML=""),this._history.textContent=""}newGame(){this._bot.stopSolving(),this._step=f.Start,this.initNewBot(this.getCurrentDifficulty()),this._gameGrid.style.setProperty("--grid-size",this._bot.grid.size.toString()),this._statusMessage.textContent="",this._history.textContent="",this._difficultySelect.disabled=!1,this._nbGamesInput.disabled=!1,this._showAllGames.disabled=!1,this._modeSelect.disabled=!1,this._mainBtn.disabled=!1}handleDelayChange(){if(this._bot instanceof A)return;let t=parseInt(this._delayInput.value);(isNaN(t)||t<v||t>M)&&(t=C,this._delayInput.value=t.toString()),this.displayDelay(),this._bot.delay=t}handleModeChange(){switch(this._modeSelect.value){case _.Visual:case _.Performance:break;default:this._modeSelect.value=k;break}const t=this._modeSelect.value;this.newGame(),t===_.Visual?(this._delayInput.disabled=!1,this._showFullInput.disabled=!1,this._showAllGames.disabled=!1):(this._delayInput.disabled=!0,this._showFullInput.disabled=!0,this._showAllGames.disabled=!0)}displayDelay(){this._delayLabel.textContent=`DÃ©lais : ${this._delayInput.value}ms`}handleShowFullChange(){this._bot instanceof y&&(this._bot.showFullSolving=this._showFullInput.checked)}async startGame(){this._step=f.Solving;const t=this.getCurrentNbGames(),e=this.getCurrentDifficulty();let i=0,s=0,o=0;if(this._difficultySelect.disabled=!0,this._nbGamesInput.disabled=!0,this._showAllGames.disabled=!0,this._modeSelect.disabled=!0,this._mainBtn.disabled=!0,this.printStatusMessage(t,i,s,0),this._showAllGames.checked||this._modeSelect.value===_.Performance)for(let n=1;n<=t;n++){try{o+=await this._bot.solve(),this._bot.grid.isWin&&i++}catch(r){console.error(r),s++}this.printStatusMessage(t,i,s,n),this.initNewBot(e)}else{const n=this._bot.solve(),r=Array.from({length:t-1},()=>this._bot=new y(e,0,!1));r.push(this._bot);const d=[];for(let c=0;c<r.length-1;c++)d.push(r[c].solve());d.push(n);for(let c=0;c<d.length;c++)try{o+=await d[c],r[c].grid.isWin&&i++}catch(m){console.error(m),s++}}this.printStatusMessage(t,i,s,t,o),this._mainBtn.disabled=!1,this._step=f.Solved}printStatusMessage(t,e,i,s,o){if(this._statusMessage.textContent=`RÃ©solus : ${s}/${t}, victoires : ${e}, erreurs : ${i}`,o){const n=o/t;this._statusMessage.textContent+=`, temps total : ${o}ms (${n}ms par grille en moyenne)`}}}document.addEventListener("DOMContentLoaded",()=>{new B});
